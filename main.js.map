{
  "version": 3,
  "sources": ["../src/tiles.js", "../src/tetromino.js", "../src/main.js"],
  "sourcesContent": ["export default Tiles = {\r\n\tBLUE: 0,\r\n\tCYAN: 1,\r\n\tORANGE: 2,\r\n\tYELLOW: 3,\r\n\tGREEN: 4,\r\n\tRED: 5,\r\n\tPURPLE: 6,\r\n\tBOARD: 7,\r\n\tBORDER_BOTTOM: 8,\r\n\tBORDER_LEFT: 9,\r\n\tBORDER_TOP: 10,\r\n\tBORDER_RIGHT: 11,\r\n\tGHOST: 12,\r\n\tHELPER: 13,\r\n\tEMPTY: 14,\r\n\tEMPTY2: 15,\r\n\tBORDER_CORNER_BOTTOM_LEFT: 16,\r\n\tBORDER_CORNER_TOP_LEFT: 17,\r\n\tBORDER_CORNER_TOP_RIGHT: 18,\r\n\tBORDER_CORNER_BOTTOM_RIGHT: 19\r\n}\r\n\r\n", "import Tiles from './tiles.js';\r\n\r\ncos = Math.cos(Math.PI / 2);\r\nsin = Math.sin(Math.PI / 2);\r\n\r\nRotationMatrix = [cos, sin, -sin, cos];\r\nTetrominoBag = [];\r\n\r\nconst Type = {\r\n    L: 'L',\r\n    I: 'I',\r\n    J: 'J',\r\n    O: 'O',\r\n    S: 'S',\r\n    T: 'T',\r\n    Z: 'Z'\r\n}\r\n\r\nconst RandomType = () => {\r\n    if (TetrominoBag.length === 0) {\r\n        // Fill the bag with all the tetromino types, but shuffle them first\r\n        let tetrominoes = Object.keys(Type);\r\n        // Fisher-Yates shuffle\r\n        for (let i = tetrominoes.length - 1; i > 0; i--) {\r\n            const j = Math.floor(Math.random() * (i + 1));\r\n            [tetrominoes[i], tetrominoes[j]] = [tetrominoes[j], tetrominoes[i]];\r\n        }\r\n\r\n        TetrominoBag = [...tetrominoes];\r\n    }\r\n\r\n    const chosen = TetrominoBag.pop();\r\n\r\n    DEBUG && console.log('Tetromino bag: ', TetrominoBag);\r\n\r\n    return chosen;\r\n}\r\n\r\nconst TypeTiles = {\r\n    L: Tiles.ORANGE,\r\n    I: Tiles.CYAN,\r\n    J: Tiles.BLUE,\r\n    O: Tiles.YELLOW,\r\n    S: Tiles.GREEN,\r\n    T: Tiles.PURPLE,\r\n    Z: Tiles.RED\r\n}\r\n\r\nconst WallKickData = {\r\n    I: [\r\n        [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],\r\n        [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],\r\n        [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]],\r\n        [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],\r\n        [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],\r\n        [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],\r\n        [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],\r\n        [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]]\r\n    ],\r\n    JLOSTZ: [\r\n        [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],\r\n        [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],\r\n        [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],\r\n        [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],\r\n        [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],\r\n        [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],\r\n        [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],\r\n        [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]]\r\n    ]\r\n}\r\n\r\nconst SpriteOffsets = {\r\n    I: [-0.5, 0.5],\r\n    O: [-0.5, 0.5],\r\n    J: [0, 1],\r\n    L: [0, 1],\r\n    S: [0, 1],\r\n    T: [0, 1],\r\n    Z: [0, 1]\r\n}\r\n\r\nconst VisualOffsets = {\r\n    I: [0, 0],\r\n    O: [0, 0],\r\n    J: [-0.5, 0.5],\r\n    L: [-0.5, 0.5],\r\n    S: [-0.5, 0.5],\r\n    T: [-0.5, 0.5],\r\n    Z: [-0.5, 0.5]\r\n}\r\n\r\nconst TetrominoData = {\r\n    L: {\r\n        cells: [\r\n\t\t\t[1, 1], [-1, 0], [0, 0], [1, 0]\r\n\t\t],\r\n        wallKicks: WallKickData.JLOSTZ\r\n    },\r\n    I: {\r\n        cells: [\r\n            [-1, 1], [0, 1], [1, 1], [2, 1]\r\n        ],\r\n        wallKicks: WallKickData.I\r\n    },\r\n    J: {\r\n        cells: [\r\n            [-1, 1], [-1, 0], [0, 0], [1, 0]\r\n        ],\r\n        wallKicks: WallKickData.JLOSTZ\r\n    },\r\n    O: {\r\n        cells: [\r\n            [0, 0], [1, 0], [0, 1], [1, 1]\r\n        ],\r\n        wallKicks: WallKickData.JLOSTZ\r\n    },\r\n    S: {\r\n        cells: [\r\n            [-1, 0], [0, 0], [0, 1], [1, 1]\r\n        ],\r\n        wallKicks: WallKickData.JLOSTZ\r\n    },\r\n    T: {\r\n        cells: [\r\n            [-1, 0], [0, 0], [1, 0], [0, 1]\r\n        ],\r\n        wallKicks: WallKickData.JLOSTZ\r\n    },\r\n    Z: {\r\n        cells: [\r\n            [-1, 1], [0, 1], [0, 0], [1, 0]\r\n        ],\r\n        wallKicks: WallKickData.JLOSTZ\r\n    }\r\n}\r\n\r\nexport function AlignVisual(tetromino, column, row, map) {\r\n    tetromino.x = map.tileToWorldX(column + VisualOffsets[tetromino.getData('type')][0]);\r\n    tetromino.y = map.tileToWorldY(20 - row + VisualOffsets[tetromino.getData('type')][1]);\r\n}\r\n\r\nexport function SpawnTetromino(phaser, x, y, scale) {\r\n    type = RandomType();\r\n    const data = TetrominoData[type];\r\n    const tetromino = phaser.add.container(x, y - (type === TetrominoData.I ? 1 : 0)).setScale(scale);\r\n    tetromino.setData('cells', data.cells);\r\n    tetromino.setData('wallKicks', data.wallKicks)\r\n    tetromino.setData('tile', TypeTiles[type]);\r\n    tetromino.setData('type', type);\r\n    tetromino.setData('rotationIndex', 0);\r\n    tetromino.setData('rotation', [0, 0]);\r\n    tetromino.setData('x', x);\r\n    tetromino.setData('y', y - (type === TetrominoData.I ? 1 : 0));\r\n    return tetromino;\r\n}\r\n\r\nexport function GetVisual(tetromino, blockSize, spriteSheet) {\r\n    offset = SpriteOffsets[type];\r\n    // Create an array of sprites, each of which created by adding a sprite to the container and setting its position\r\n    data.cells.map((cell) => {\r\n        const sprite = phaser.add.sprite(\r\n            (cell[0] + offset[0]) * blockSize, \r\n            (1 - cell[1] - offset[1]) * blockSize, \r\n            spriteSheet, \r\n            TypeTiles[type]);\r\n        tetromino.add(sprite);\r\n        return sprite;\r\n    });\r\n}\r\n\r\nfunction Wrap(input, min, max) {\r\n    if (input < min) {\r\n        return max - (min - input) % (max - min);\r\n    }\r\n    else {\r\n        return min + (input - min) % (max - min);\r\n    }\r\n}\r\n\r\nexport function Rotate(graphics, map, scale, tetromino, direction) {\r\n    originalRotation = tetromino.getData('rotationIndex') || 0;\r\n    rotationIndex = Wrap(originalRotation + direction, 0, 4);\r\n    \r\n    DEBUG && console.log('Rotation: ', rotationIndex);\r\n    \r\n    ApplyRotationMatrix(tetromino, direction);\r\n\r\n    if (!TestWallKicks(graphics, map, scale, tetromino, rotationIndex, direction)) {\r\n        rotationIndex = originalRotation;\r\n        ApplyRotationMatrix(tetromino, -direction);\r\n    }\r\n    tetromino.setData('rotationIndex', rotationIndex);\r\n}\r\n\r\nfunction TestWallKicks(graphics, map, scale, tetromino, rotationIndex, rotationDirection) {\r\n    wallKicks = tetromino.getData('wallKicks');\r\n    wallKickIndex = GetWallKickIndex(rotationIndex, rotationDirection);\r\n    \r\n    DEBUG && console.log('Wall kicks being evaluated: ', wallKicks[wallKickIndex]);\r\n    for (i = 0; i < 5; i++) {\r\n        translation = wallKicks[wallKickIndex][i];\r\n        if (Move(graphics, map, scale, tetromino, translation, true)) {\r\n            DEBUG && console.log('Wall kick success');\r\n            return true;\r\n        }\r\n    }\r\n    DEBUG && console.log('Wall kick failure');\r\n    return false;\r\n}\r\n\r\nfunction GetWallKickIndex(rotationIndex, rotationDirection) {\r\n    wallKickIndex = rotationIndex * 2;\r\n\r\n    if (rotationDirection < 0) {\r\n        wallKickIndex--;\r\n    }\r\n\r\n    return Wrap(wallKickIndex, 0, 8);\r\n}\r\n\r\nfunction isValidMove(graphics, map, scale, tetromino, translation, testingWallKicks) {\r\n    const cells = tetromino.getData('cells');\r\n    const type = tetromino.getData('type');\r\n    const x = tetromino.getData('x');\r\n    const y = tetromino.getData('y');\r\n    \r\n    if (DEBUG) {\r\n        graphics.clear();\r\n        console.log('Testing move: ', translation)\r\n    }\r\n    \r\n    for (let i = 0; i < cells.length; i++) {\r\n        const vecX = x + cells[i][0] + translation[0];\r\n        const vecY = y + cells[i][1] - translation[1];\r\n        \r\n        /*if (vecX < 0 || vecX > 9 || vecY < 0 || vecY > 20) {\r\n            DEBUG && console.log('Out of bounds: ', vecX, vecY);\r\n            return false;\r\n        }*/\r\n        \r\n        if (DEBUG) {\r\n            wx = map.tileToWorldX(vecX);\r\n            wy = map.tileToWorldY(20 - vecY);\r\n            \r\n            graphics.lineStyle(1, 0xff00ff);\r\n            graphics.strokeRectShape(new Phaser.Geom.Rectangle(wx, wy, 64 * scale, 64 * scale));\r\n        }\r\n\r\n        if (vecX % 1 !== 0 || vecY % 1 !== 0) {\r\n            DEBUG && console.log('Bug: ', vecX, vecY);\r\n            return false;\r\n        }\r\n\r\n        const tile = map.getTileAt(vecX, 20 - vecY);\r\n        if (!tile || tile.index !== Tiles.BOARD) {\r\n            DEBUG && console.log('Tile occupied');\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nexport function Move(graphics, map, scale, tetromino, translation, testingWallKicks) {\r\n    isValid = isValidMove(graphics, map, scale, tetromino, translation, testingWallKicks);\r\n    if (isValid) {\r\n        tetromino.setData('x', tetromino.getData('x') + translation[0]);\r\n        tetromino.setData('y', tetromino.getData('y') - translation[1]);\r\n        tetromino.x = map.tileToWorldX(tetromino.getData('x'));\r\n        tetromino.y = map.tileToWorldY(19 - tetromino.getData('y'));\r\n    }\r\n    return isValid;\r\n}\r\n\r\nfunction ApplyRotationMatrix(tetromino, direction) {\r\n    const offset = VisualOffsets[tetromino.getData('type')];\r\n    const data = tetromino.getData('cells');\r\n    const type = tetromino.getData('type');\r\n    const rotationMatrix = RotationMatrix;\r\n    const rotated = [];\r\n    const specialCase = type === Type.O || type === Type.I;\r\n\r\n    if (specialCase) { \r\n        for (let i = 0; i < data.length; i++) {\r\n            data[i][0] -= 0.5;\r\n            data[i][1] -= 0.5;\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < data.length; i++) {\r\n        const rotatedX = parseFloat((data[i][0] * rotationMatrix[0] * direction + (data[i][1] * rotationMatrix[1] * direction)).toFixed(1));\r\n        const rotatedY = parseFloat((data[i][0] * rotationMatrix[2] * direction + (data[i][1] * rotationMatrix[3] * direction)).toFixed(1));\r\n        rotated.push([specialCase ? Math.ceil(rotatedX) : Math.round(rotatedX), specialCase ? Math.ceil(rotatedY) : Math.round(rotatedY)]);\r\n    }\r\n\r\n    tetromino.setData('cells', rotated);\r\n    tmp = [parseFloat((offset[0] * rotationMatrix[0] * direction + (offset[1] * rotationMatrix[1] * direction)).toFixed(1)),\r\n           parseFloat((offset[0] * rotationMatrix[2] * direction + (offset[1] * rotationMatrix[3] * direction)).toFixed(1))];\r\n    tetromino.setData('rotation', tmp);\r\n    \r\n    //tetromino.setRotation(tetromino.rotation + direction * Math.PI / 2);\r\n    \r\n    return rotated;\r\n}", "import { SpawnTetromino, Rotate, Move } from \"./tetromino\";\nimport Tiles from \"./tiles\";\n\nWIDTH = 640;\nHEIGHT = 1024;\nDEBUG = false;\n/*\nwindow.innerWidth * window.devicePixelRatio,\nwindow.innerHeight * window.devicePixelRatio,\n*/\nBOARD_WIDTH = 10;\nBOARD_HEIGHT = 20;\nBLOCK_SIZE = 64;\n\nisClicking = false;\nswipeDirection = \"\";\ntouchDeltaX = 0;\ntouchDeltaY = 0;\nswipeDelay = 0;\ndropped = false;\nclicked = false;\ndragged = false;\n\nclass Jetris extends Phaser.Scene\n{\n    constructor ()\n    {\n        super({ key: 'Jetris', active: true});\n\n        this.container;\n\t\tthis.level;\n        this.center = {x: WIDTH / 2, y: HEIGHT / 2}\n\t\tthis.deltaX = (this.center.x * 2) / 8;\n\t\tthis.deltaY = (this.center.y * 2) / 20;\n\t\tthis.gameScale = this.deltaX * 2.5 / ((this.center.x));\n\t\tthis.gameScaleY = this.deltaY * 2.5 / ((this.center.y));\n\t\tthis.adjustedBlockSize = BLOCK_SIZE * this.gameScale;\n\t\tthis.elapsed = 0;\n\t\tthis.activePiece;\n\t\tthis.graphics;\n\t\tthis.gameOver = false;\n    }\n\n    preload ()\n    {\n        this.load.spritesheet('tetris', 'assets/Sprites/tetris.png', { frameWidth: BLOCK_SIZE, frameHeight: BLOCK_SIZE });\n\t\tthis.load.spritesheet('fullscreen', 'assets/ui/fullscreen.png', { frameWidth: BLOCK_SIZE, frameHeight: BLOCK_SIZE });\n    }\n\n\tcreateTileMap() {\n\t\tthis.level = Array.from({ length: BOARD_HEIGHT }, () => Array.from({ length: BOARD_WIDTH }, () => Tiles.BOARD));\n\t\tthis.map = this.make.tilemap({ data: this.level, tileWidth: BLOCK_SIZE, tileHeight: BLOCK_SIZE });\n        const tiles = this.map.addTilesetImage('tetris');\n        const layer = this.map.createLayer(\n\t\t\t0, \n\t\t\ttiles, \n\t\t\tthis.center.x - ((BOARD_WIDTH / 2) * BLOCK_SIZE * this.gameScale),\n\t\t\tBLOCK_SIZE * this.gameScale).setScale(this.gameScale);\n\t}\n\n\tcheckFractions(x, y) {\n\t\tif (x % 1 !== 0 || y % 1 !== 0) {\n\t\t\tDEBUG && console.log('bug: ', x , y);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tsetTile(x, y, tile) {\n\t\tif (this.checkFractions(x, y)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.map.putTileAt(tile, x, BOARD_HEIGHT - y);\n\t}\n\n\tgetTile(x, y) {\n\t\tif (this.checkFractions(x, y)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.map.getTileAt(x, BOARD_HEIGHT - y);\n\t}\n\n\tsetTetromino(tetromino) {\n\t\tlet data = tetromino.getData('cells');\n\t\tlet x = tetromino.getData('x');\n\t\tlet y = tetromino.getData('y');\n\n\t\tif (this.checkFractions(x, y)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\tfor (let j = 0; j < data[i].length - 1; j++) {\n\t\t\t\t\n\t\t\t\tif (this.checkFractions(data[i][j], data[i][j + 1])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlet currentTile = this.getTile(x + data[i][j], (y + data[i][j + 1]));\n\t\t\t\tif (currentTile && currentTile.index === Tiles.BOARD) {\n\t\t\t\t\tthis.setTile(x + data[i][j], y + data[i][j + 1], tetromino.getData('tile'));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.gameOver = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclearTetromino(tetromino) {\n\t\tlet data = tetromino.getData('cells');\n\t\tlet x = tetromino.getData('x');\n\t\tlet y = tetromino.getData('y');\n\n\t\tif (this.checkFractions(x, y)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\tfor (let j = 0; j < data[i].length - 1; j++) {\n\t\t\t\tif (this.checkFractions(data[i][j], data[i][j + 1])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.setTile(x + data[i][j], y + data[i][j + 1], 7);\n\t\t\t}\n\t\t}\n\t}\n\n\taddFullScreenToggle() {\n\t\t// Fullscreen button\n\t\tconst button = this.add.image(WIDTH - 16, 16, 'fullscreen', 0)\n\t\t\t.setOrigin(1, 0)\n\t\t\t.setScale(0.25)\n\t\t\t.setInteractive();\n\t\t\n\t\tbutton.on('pointerup', function ()\n        {\n            if (this.scale.isFullscreen) {\n                button.setFrame(0);\n\n                this.scale.stopFullscreen();\n            } else {\n                button.setFrame(1);\n                this.scale.startFullscreen();\n            }\n\n        }, this);\n\t}\n\n\tmoveActivePiece (vector) {\n\t\tif (this.activePiece) {\n\t\t\tthis.clearTetromino(this.activePiece);\n\t\t\tMove(this.graphics, this.map, this.gameScale, this.activePiece, vector)\n\t\t\tthis.setTetromino(this.activePiece);\n\t\t}\n\t}\n\n\trotateActivePiece (direction) {\n\t\tthis.clearTetromino(this.activePiece);\n\t\tRotate(this.graphics, this.map, this.gameScale, this.activePiece, direction);\n\t\tthis.setTetromino(this.activePiece);\n\t}\n\n\tlockTetromino (tetromino) {\n\t\t// Find the set of y coordinates on the board that the tetromino occupies\n\t\tlet ySet = new Set();\n\t\tlet data = tetromino.getData('cells');\n\t\tlet x = tetromino.getData('x');\n\t\tlet y = tetromino.getData('y');\n\n\t\tif (this.checkFractions(x, y)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\tfor (let j = 0; j < data[i].length - 1; j++) {\n\t\t\t\tif (this.checkFractions(data[i][j], data[i][j + 1])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tySet.add(y + data[i][j + 1]);\n\t\t\t}\n\t\t}\n\n\t\t// Sort the set of y coordinates\n\t\tySet = Array.from(ySet).sort((a, b) => b - a);\n\n\t\t// For each y coordinate, check if all tiles within the tileMap (this.map) are occupied\n\t\t// If so, clear the row and shift all rows above it down by one\n\t\tfor (let i = 0; i < ySet.length; i++) {\n\t\t\tlet row = ySet[i];\n\t\t\tlet isFull = true;\n\t\t\tfor (let j = 0; j < BOARD_WIDTH; j++) {\n\t\t\t\tlet tile = this.getTile(j, row);\n\t\t\t\tif (!tile || tile.index === Tiles.BOARD) {\n\t\t\t\t\tisFull = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isFull) {\n\t\t\t\tfor (let j = 0; j < BOARD_WIDTH; j++) {\n\t\t\t\t\tthis.setTile(j, row, Tiles.BOARD);\n\t\t\t\t}\n\t\t\t\tfor (let k = row + 1; k < BOARD_HEIGHT; k++) {\n\t\t\t\t\tfor (let j = 0; j < BOARD_WIDTH; j++) {\n\t\t\t\t\t\tlet tile = this.getTile(j, k);\n\t\t\t\t\t\tif (tile && tile.index !== Tiles.BOARD) {\n\t\t\t\t\t\t\tthis.setTile(j, k - 1, tile.index);\n\t\t\t\t\t\t\tthis.setTile(j, k, Tiles.BOARD);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdrop () {\n\t\tif (!this.gameOver) {\n\t\t\tthis.clearTetromino(this.activePiece);\n\t\t\twhile (Move(this.graphics, this.map, this.gameScale, this.activePiece, [0, 1])) {}\n\t\t\tthis.setTetromino(this.activePiece);\n\t\t\tthis.lockTetromino(this.activePiece);\n\t\t\tthis.spawn();\n\t\t\tthis.setTetromino(this.activePiece); \n\t\t\tthis.elapsed = 0;\n\t\t}\n\t}\n\n    create ()\n    {\n\t\tthis.createTileMap();\n\t\tthis.addFullScreenToggle();\n\t\tthis.spawn();\n\t\t\n\t\tthis.input.addPointer(1);\n\n\t\tthis.input.keyboard.on('keydown-LEFT', () =>\n        {\n\t\t\tthis.moveActivePiece([-1, 0])\n        });\n\n\t\tthis.input.keyboard.on('keydown-RIGHT', () =>\n        {\n\t\t\tthis.moveActivePiece([1, 0])\n        });\n\n\t\tthis.input.keyboard.on('keydown-DOWN', () =>\n        {\n\t\t\tthis.moveActivePiece([0, 1])\n        });\n\n\t\tDEBUG && this.input.keyboard.on('keydown-UP', () =>\n        {\n\t\t\tthis.moveActivePiece([0, -1])\n        });\n\n\t\tthis.input.keyboard.on('keydown-E', () =>\n        {\n\t\t\tthis.rotateActivePiece(1)\n        });\n\n\t\tthis.input.keyboard.on('keydown-Q', () =>\n        {\n\t\t\tthis.rotateActivePiece(-1)\n        });\n\n\t\tthis.input.keyboard.on('keydown-SPACE', () =>\n\t\t{\n\t\t\tthis.drop()\n\t\t});\n\n\t\t//pause game when 'P' is pressed\n\t\tthis.input.keyboard.on('keydown-P', () =>\n\t\t{\n\t\t\t// Toggle pause\n\t\t\tthis.scene.isPaused() ? this.scene.resume() : this.scene.pause();\n\t\t});\n\n\t\tthis.input.keyboard.on('keydown-ESC', () =>\n        {\n\t\t\tthis.map.fill(Tiles.BOARD);\n\t\t\tthis.gameOver = false;\n\t\t\tthis.spawn();\n\t\t\tthis.setTetromino(this.activePiece);\n        });\n\n\t\tthis.graphics = this.add.graphics();\n\t\tthis.setTetromino(this.activePiece);\n\n\t\tconsole.log(\n\t\t\twindow.innerWidth,\n\t\t\twindow.innerHeight,\n\t\t\twindow.devicePixelRatio\n\t\t);\n    }\n\n\tspawn () {\n\t\tthis.activePiece && this.activePiece.destroy();\n\t\tthis.activePiece = SpawnTetromino(this, 4, 19, this.gameScale);\n\t}\n\n\tprocessTouch() {\n\t\tif(this.input.activePointer.isDown) {\n\t\t\tclicked = true;\n\t\t\tif(Math.abs(this.input.activePointer.x - touchDeltaX) >= 50) {\n\t\t\t\tif(this.input.activePointer.x < touchDeltaX) {\n\t\t\t\t\tswipeDirection = \"left\";\n\t\t\t\t} else if(this.input.activePointer.x > touchDeltaX && touchDeltaX != 0) {\n\t\t\t\t\tswipeDirection = \"right\";\n\t\t\t\t} else {\n\t\t\t\t\tswipeDirection = \"\";\n\t\t\t\t\ttouchDeltaX = 0;\n\t\t\t\t}\n\t\t\t\ttouchDeltaX = this.input.activePointer.x;\n\n\t\t\t\tif (swipeDirection != \"\"){\n\t\t\t\t\tthis.moveActivePiece([swipeDirection == \"left\" ? -1 : 1, 0]);\n\t\t\t\t\tdragged = true;\n\t\t\t\t}\n\t\t\t} else if (!dropped && Math.abs(this.input.activePointer.y - touchDeltaY) >= 200) {\n\t\t\t\tif(this.input.activePointer.y > touchDeltaY && touchDeltaY != 0) {\n\t\t\t\t\tswipeDirection = \"down\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tswipeDirection = \"\";\n\t\t\t\t\ttouchDeltaY = 0;\n\t\t\t\t}\n\t\t\t\ttouchDeltaY = this.input.activePointer.y;\n\n\t\t\t\tif (swipeDirection == \"down\"){\n\t\t\t\t\tthis.drop();\n\t\t\t\t\tdropped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttouchDeltaX = 0;\n\t\t\ttouchDeltaY = 0;\n\t\t\t\n\t\t\tif (clicked && !dragged && !dropped) {\n\t\t\t\tif (this.input.activePointer.x < this.center.x) {\n\t\t\t\t\tthis.rotateActivePiece(-1);\n\t\t\t\t} else {\n\t\t\t\t\tthis.rotateActivePiece(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tclicked = false;\n\t\t\tdropped = false;\n\t\t\tdragged = false;\n\t\t}\n\t}\n\n    update (time, delta)\n    {\n\t\tif (!this.gameOver) {\n\n\t\t\tthis.processTouch();\n\n\t\t\tthis.elapsed += delta;\n\t\t\tif (this.elapsed > 1000) {\n\t\t\t\tthis.elapsed = 0;\n\t\t\t}\n\n\t\t\tif (this.elapsed === 0 && this.activePiece && !DEBUG) {\n\t\t\t\tthis.clearTetromino(this.activePiece);\n\t\t\t\tif (!Move(this.graphics, this.map, this.gameScale, this.activePiece, [0, 1])) {\n\t\t\t\t\tthis.setTetromino(this.activePiece);\n\t\t\t\t\tthis.lockTetromino(this.activePiece);\n\t\t\t\t\tthis.spawn();\n\t\t\t\t}\n\t\t\t\tthis.setTetromino(this.activePiece);\n\t\t\t}\n\t\t}\n    }\n}\n\nconst config = {\n    type: Phaser.WEBGL,\n\tscale: {\n        mode: Phaser.Scale.FIT,\n        parent: 'jetris',\n        autoCenter: Phaser.Scale.CENTER_BOTH,\n        width: WIDTH,\n        height: HEIGHT\n    },\n    width: WIDTH,\n    height: HEIGHT,\n    backgroundColor: '#2d2d2d',\n    scene: [ Jetris ]\n};\n\nconst game = new Phaser.Game(config);"],
  "mappings": "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",
  "names": []
}
