<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Typi</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  html, body { height:100%; background:#1a1a2e; font-family:Arial, sans-serif; }

  /* Optional centering */
  body { display:flex; align-items:center; justify-content:center; }

  /* Let the container size itself to the canvas, not the viewport */
  #game-container {
    position: relative;
    display: inline-block; /* wraps to canvas' real pixel size */
  }

  /* Overlay is glued to the viewport and transformed to the canvas rect */
  #keyboard-overlay {
    position: fixed;          /* important: viewport coords */
    left: 0; top: 0;
    width: 0; height: 0;      /* set via JS to base size */
    pointer-events: none;
    transform-origin: top left;
    z-index: 9999;
    display: block;
  }

  #keyboard-overlay svg {
    display: block;
    width: 100%;
    height: 100%;
  }

  /* Optional: avoid baseline gap on canvas */
  #game-container canvas { display:block; }
</style>
</head>
<body>
  <div id="game-container">
    <!-- Phaser mounts its <canvas> here via parent:'game-container' -->
  </div>

  <!-- Overlay lives in the DOM once and is transformed to the canvas -->
  <div id="keyboard-overlay"></div>

  <script src="./phaser.js"></script>
  <script type="module" src="./src/main.js"></script>

  <script type="module">
    // === Configure to your base game resolution ===
    const BASE_W = 1280;
    const BASE_H = 800;
    const OFFSET_X = -12;   // move right in game-space units
    const OFFSET_Y = 53;   // move down in game-space units
    const EXTRA_SCALE = 1.27; // enlarge 10% overall

    // Inject your SVG (author at base size; viewBox matches base)
    const overlay = document.getElementById('keyboard-overlay');
    overlay.innerHTML = `
      <svg viewBox="0 0 ${BASE_W} ${BASE_H}"
           xmlns="http://www.w3.org/2000/svg"
           preserveAspectRatio="none">
      </svg>
    `;

    function syncOverlayToCanvas() {
      const canvas = document.querySelector('#game-container canvas');
      if (!canvas) return;

      const r = canvas.getBoundingClientRect();

      // Scale factors from base -> current canvas CSS size
      const sx = (r.width  / BASE_W) * EXTRA_SCALE;
      const sy = (r.height / BASE_H) * EXTRA_SCALE;

      // Base overlay size
      overlay.style.width  = BASE_W + 'px';
      overlay.style.height = BASE_H + 'px';

      // Translate to canvas top-left (account for scroll)
      // Also include your game-space offset, scaled accordingly
      const x = Math.round(r.left + window.scrollX + OFFSET_X * (r.width / BASE_W));
      const y = Math.round(r.top  + window.scrollY + OFFSET_Y * (r.height / BASE_H));

      // Apply translate + scale
      overlay.style.transform = `translate(${x}px, ${y}px) scale(${sx}, ${sy})`;
    }

    // Run once canvas is present, then track changes
    const init = () => {
      syncOverlayToCanvas();

      // Layout/viewport changes
      window.addEventListener('resize', syncOverlayToCanvas);
      window.addEventListener('scroll', syncOverlayToCanvas, { passive: true });
      document.addEventListener('fullscreenchange', syncOverlayToCanvas);

      if (window.visualViewport) {
        visualViewport.addEventListener('resize', syncOverlayToCanvas);
        visualViewport.addEventListener('scroll', syncOverlayToCanvas);
      }

      // Track Phaser scale changes (canvas size changes)
      const canvas = document.querySelector('#game-container canvas');
      if (canvas) new ResizeObserver(syncOverlayToCanvas).observe(canvas);
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
